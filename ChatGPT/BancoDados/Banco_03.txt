Data a estrutura da "tabela propostas":

create table public.propostas (
  id_proposta integer generated by default as identity not null,
  id_cliente integer not null,
  num_proposta text null,
  data_emissao date null,
  validade date null,
  cond_pagamento text null,
  referencia text null,
  constraint propostas_pkey primary key (id_proposta),
  constraint fk_proposta_cliente foreign KEY (id_cliente) references clientes (id) on delete CASCADE
) TABLESPACE pg_default;

Crie uma sequencia de comandos SQL para o editor SUPABASE para:
1. Criar uma tabela chamada "itens" com os campos:
     id_item como chave prim√°ria sequencial (integer generated by default as identity not null)
     codigo text null,
     descricao text null,
     prazo text null,
     preco numeric(12, 2) null,
     desconto numeric(12, 0) null
     qtd numeric(12, 0) null

2. Criar uma tabela chamada "item_proposta" com os campos:
     id_itprop como chave prim√°ria sequencial (integer generated by default as identity not null)
     id_proposta null, ( vem da tabela "propostas")
     id_item integer null, ( vem da tabela "itens")

3. Regras:
- Uma proposta ("tabela propostas") pode conter v√°rios itens "tabela item_proposta"
======================================================================================
Abaixo est√° a sequ√™ncia completa de comandos SQL, totalmente compat√≠vel com PostgreSQL/Supabase, para criar as tabelas itens e item_proposta, incluindo chaves prim√°rias, FKs e regras de relacionamento.

Basta copiar e colar no SQL Editor do Supabase e executar.
‚úÖ 1. Criar tabela itens
CREATE TABLE IF NOT EXISTS public.itens (
    id_item INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    codigo TEXT NULL,
    descricao TEXT NULL,
    prazo TEXT NULL,
    preco NUMERIC(12,2) NULL,
    desconto NUMERIC(12,0) NULL,
    qtd NUMERIC(12,0) NULL
);
‚úÖ 2. Criar tabela item_proposta com FK para propostas e itens
CREATE TABLE IF NOT EXISTS public.item_proposta (
    id_itprop INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_proposta INTEGER NULL REFERENCES public.propostas(id_proposta) ON DELETE CASCADE,
    id_item INTEGER NULL REFERENCES public.itens(id_item) ON DELETE CASCADE
);
üìå 3. Regras atendidas
Uma proposta pode ter v√°rios itens
‚Üí garantido porque item_proposta cont√©m v√°rios registros apontando para a mesma id_proposta.

Integridade garantida pelo CASCADE
‚Üí se voc√™ apagar uma proposta, todos os itens relacionados na tabela item_proposta s√£o automaticamente apagados.

Chaves prim√°rias sequenciais usando IDENTITY (compat√≠vel com Supabase/PostgreSQL 15)
==========================================================================================================
Crie Views autom√°ticas unindo propostas + itens
‚úî Triggers para atualizar totais automaticamente
‚úî CRUD completo em Python para esses relacionamentos

Perfeito ‚Äî vou entregar tudo pronto e test√°vel:
Views que unem propostas + itens (com linha por item e totais por proposta).
Triggers + fun√ß√£o PL/pgSQL que recalculam automaticamente os totais da proposta sempre que itens s√£o adicionados/alterados/removidos (ou quando um item muda pre√ßo/quantidade/desconto).
M√≥dulo Python (CRUD) para gerenciar itens e item_proposta e para consultar a view de propostas com itens.
Observa√ß√£o: para manter totais persistidos e simples de consultar, acrescentarei duas colunas em propostas:
total_qtd NUMERIC(12,2) DEFAULT 0 e total_valor NUMERIC(12,2) DEFAULT 0.
(Se preferir que os totais fiquem apenas em view, diga que eu removo as colunas/persist√™ncia.)

1) SQL ‚Äî criar view, colunas adicionais e triggers
Cole tudo no SQL Editor do Supabase (executar em sequ√™ncia).
-- 0) (Opcional) Ajuste: adicionar colunas de total na tabela propostas para armazenar os totais calculados
ALTER TABLE public.propostas
  ADD COLUMN IF NOT EXISTS total_qtd NUMERIC(12,2) DEFAULT 0,
  ADD COLUMN IF NOT EXISTS total_valor NUMERIC(12,2) DEFAULT 0;

-- 1) View: lista propostas com seus itens (uma linha por item) e total por linha
CREATE OR REPLACE VIEW public.propostas_com_itens AS
SELECT
  p.id_proposta,
  p.id_cliente,
  p.num_proposta,
  p.data_emissao,
  p.validade,
  p.cond_pagamento,
  p.referencia,
  ip.id_itprop,
  i.id_item,
  i.codigo,
  i.descricao,
  COALESCE(i.preco, 0)    AS preco,
  COALESCE(i.qtd, 0)      AS qtd,
  COALESCE(i.desconto,0)  AS desconto,
  (COALESCE(i.preco,0) * COALESCE(i.qtd,0) - COALESCE(i.desconto,0))::numeric(12,2) AS linha_total
FROM public.propostas p
LEFT JOIN public.item_proposta ip ON ip.id_proposta = p.id_proposta
LEFT JOIN public.itens i ON i.id_item = ip.id_item;

-- 2) View: resumo por proposta (agrega os valores da view anterior)
CREATE OR REPLACE VIEW public.resumo_proposta_totais AS
SELECT
  p.id_proposta,
  p.num_proposta,
  COALESCE(SUM(pc.linha_total), 0)::numeric(12,2) AS total_valor,
  COALESCE(SUM(pc.qtd), 0)::numeric(12,2) AS total_qtd,
  COUNT(pc.id_itprop) AS itens_count
FROM public.propostas p
LEFT JOIN public.propostas_com_itens pc ON pc.id_proposta = p.id_proposta
GROUP BY p.id_proposta, p.num_proposta;

-- 3) Fun√ß√£o PL/pgSQL que recalcula os totais de uma proposta espec√≠fica
CREATE OR REPLACE FUNCTION public._recalc_totals_for_proposta(p_id INTEGER)
RETURNS void AS $$
DECLARE
    v_total_valor NUMERIC(24,6);
    v_total_qtd   NUMERIC(24,6);
BEGIN
    SELECT
      COALESCE(SUM((COALESCE(i.preco,0) * COALESCE(i.qtd,0) - COALESCE(i.desconto,0))::numeric(12,2)), 0),
      COALESCE(SUM(COALESCE(i.qtd,0)::numeric(12,2)), 0)
    INTO v_total_valor, v_total_qtd
    FROM public.item_proposta ip
    JOIN public.itens i ON i.id_item = ip.id_item
    WHERE ip.id_proposta = p_id;

    UPDATE public.propostas
    SET total_valor = v_total_valor::numeric(12,2),
        total_qtd   = v_total_qtd::numeric(12,2)
    WHERE id_proposta = p_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 4) Fun√ß√£o trigger que reage a INSERT/UPDATE/DELETE na tabela item_proposta
CREATE OR REPLACE FUNCTION public.trg_item_proposta_changes()
RETURNS TRIGGER AS $$
BEGIN
    IF (TG_OP = 'INSERT') THEN
        PERFORM public._recalc_totals_for_proposta(NEW.id_proposta);
        RETURN NEW;
    ELSIF (TG_OP = 'UPDATE') THEN
        -- Se id_proposta mudou, recalcula para OLD e NEW
        IF (OLD.id_proposta IS DISTINCT FROM NEW.id_proposta) THEN
            PERFORM public._recalc_totals_for_proposta(OLD.id_proposta);
            PERFORM public._recalc_totals_for_proposta(NEW.id_proposta);
        ELSE
            PERFORM public._recalc_totals_for_proposta(NEW.id_proposta);
        END IF;
        RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        PERFORM public._recalc_totals_for_proposta(OLD.id_proposta);
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 5) Attach trigger to item_proposta
DROP TRIGGER IF EXISTS trg_item_proposta_changes ON public.item_proposta;
CREATE TRIGGER trg_item_proposta_changes
AFTER INSERT OR UPDATE OR DELETE ON public.item_proposta
FOR EACH ROW EXECUTE FUNCTION public.trg_item_proposta_changes();

-- 6) Fun√ß√£o trigger que reage a UPDATE na tabela itens (preco, qtd, desconto)
--    Se pre√ßo/qtde/desconto mudarem, precisa recalcular todas propostas que usam esse item
CREATE OR REPLACE FUNCTION public.trg_itens_update()
RETURNS TRIGGER AS $$
DECLARE
    rec RECORD;
BEGIN
    -- Apenas se algum dos campos relevantes foi modificado
    IF (TG_OP = 'UPDATE') THEN
        IF (OLD.preco IS DISTINCT FROM NEW.preco OR OLD.qtd IS DISTINCT FROM NEW.qtd OR OLD.desconto IS DISTINCT FROM NEW.desconto) THEN
            FOR rec IN
                SELECT ip.id_proposta
                FROM public.item_proposta ip
                WHERE ip.id_item = NEW.id_item
            LOOP
                PERFORM public._recalc_totals_for_proposta(rec.id_proposta);
            END LOOP;
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 7) Attach trigger to itens (after update)
DROP TRIGGER IF EXISTS trg_itens_update ON public.itens;
CREATE TRIGGER trg_itens_update
AFTER UPDATE ON public.itens
FOR EACH ROW EXECUTE FUNCTION public.trg_itens_update();

Explica√ß√£o r√°pida do comportamento:

propostas_com_itens: view com cada item associado √† proposta e o total de cada linha (linha_total).
resumo_proposta_totais: view agregada com total_valor, total_qtd, itens_count.
_recalc_totals_for_proposta(p_id): fun√ß√£o que soma linha_total e qtd para a proposta p_id e grava em propostas.total_valor e propostas.total_qtd.
trg_item_proposta_changes: acionada ap√≥s INSERT/UPDATE/DELETE em item_proposta, recalcula a(s) proposta(s) afetada(s).
trg_itens_update: acionada quando um item muda (pre√ßo/qtd/desconto), recalcula todas propostas que referenciam esse item.

2) CRUD completo em Python para itens e item_proposta + leitura das views

Abaixo um m√≥dulo Python (arquivo crud_itens.py) que voc√™ pode usar com supabase-py (v2). Ele fornece fun√ß√µes para criar/atualizar/deletar itens, vincular itens a propostas e buscar propostas com itens via view.
Pr√©-requisitos: pip install supabase-client (ou supabase) ‚Äî ajuste import conforme sua vers√£o. No exemplo uso from supabase import create_client.

# crud_itens.py
from supabase import create_client
from typing import List, Dict, Any

class SupabaseCRUD:
    def __init__(self, url: str, key: str):
        self.supabase = create_client(url, key)

    # ---------- ITENS ----------
    def criar_item(self, dados: Dict[str, Any]) -> Dict[str, Any]:
        """dados: dict com keys: codigo, descricao, prazo, preco, desconto, qtd"""
        res = self.supabase.table("itens").insert(dados).execute()
        return res.data

    def listar_itens(self, filtro: dict = None) -> List[Dict[str, Any]]:
        q = self.supabase.table("itens").select("*")
        if filtro:
            for k, v in filtro.items():
                q = q.eq(k, v)
        return q.execute().data

    def atualizar_item(self, id_item: int, dados: Dict[str, Any]) -> Dict[str, Any]:
        return self.supabase.table("itens").update(dados).eq("id_item", id_item).execute().data

    def deletar_item(self, id_item: int) -> Dict[str, Any]:
        return self.supabase.table("itens").delete().eq("id_item", id_item).execute().data

    # ---------- ITEM_PROPOSTA (associa√ß√£o) ----------
    def adicionar_item_a_proposta(self, id_proposta: int, id_item: int) -> Dict[str, Any]:
        payload = {"id_proposta": id_proposta, "id_item": id_item}
        return self.supabase.table("item_proposta").insert(payload).execute().data

    def remover_item_de_proposta(self, id_itprop: int = None, id_proposta: int = None, id_item: int = None) -> Dict[str, Any]:
        q = self.supabase.table("item_proposta").delete()
        if id_itprop is not None:
            q = q.eq("id_itprop", id_itprop)
        if id_proposta is not None:
            q = q.eq("id_proposta", id_proposta)
        if id_item is not None:
            q = q.eq("id_item", id_item)
        return q.execute().data

    def listar_itens_da_proposta(self, id_proposta: int) -> List[Dict[str, Any]]:
        # utiliza a view criada 'propostas_com_itens' para obter dados ricos
        res = self.supabase.table("propostas_com_itens").select("*").eq("id_proposta", id_proposta).execute()
        return res.data

    # ---------- CONSULTAS AUXILIARES ----------
    def obter_resumo_proposta(self, id_proposta: int) -> Dict[str, Any]:
        res = self.supabase.table("resumo_proposta_totais").select("*").eq("id_proposta", id_proposta).execute()
        return res.data[0] if res.data else {"id_proposta": id_proposta, "total_valor": 0, "total_qtd": 0, "itens_count": 0}

    def get_proposta_com_itens(self, id_proposta: int) -> Dict[str, Any]:
        proposta = self.supabase.table("propostas").select("*").eq("id_proposta", id_proposta).execute().data
        itens = self.listar_itens_da_proposta(id_proposta)
        return {"proposta": proposta[0] if proposta else None, "itens": itens}

Exemplo de uso:
from crud_itens import SupabaseCRUD

SUPABASE_URL = "https://SEU_PROJETO.supabase.co"
SUPABASE_KEY = "SUA_KEY_AQUI"

db = SupabaseCRUD(SUPABASE_URL, SUPABASE_KEY)

# Criar item
item = db.criar_item({
    "codigo": "IT-001",
    "descricao": "Servi√ßo A",
    "prazo": "7 dias",
    "preco": 150.00,
    "desconto": 0,
    "qtd": 1
})
print("Item criado:", item)

# Vincular item a proposta 1
db.adicionar_item_a_proposta(id_proposta=1, id_item=item[0]["id_item"])

# Ler itens da proposta 1
itens = db.listar_itens_da_proposta(1)
print("Itens da proposta 1:", itens)

# Obter resumo (total calculado e persistido pela trigger)
resumo = db.obter_resumo_proposta(1)
print("Resumo proposta 1:", resumo)

3) Observa√ß√µes, boas pr√°ticas e pontos importantes

Permiss√µes: Triggers e fun√ß√µes PL/pgSQL foram criadas com SECURITY DEFINER para facilitar execu√ß√£o ‚Äî verifique permiss√µes do seu role. Para criar/alterar fun√ß√µes/triggers voc√™ precisa da service_role ou de um usu√°rio com privil√©gios suficientes no SQL Editor.
Consist√™ncia: toda altera√ß√£o em item_proposta ou em itens que afete pre√ßo/quantidade/desconto dispara recalculo autom√°tico. Isso mant√©m propostas.total_valor sempre consistente.
Transa√ß√µes: as triggers rodam dentro da transa√ß√£o que executou a modifica√ß√£o; n√£o h√° necessidade de chamadas extras no client.
Performance: para milhares de itens/propostas, as fun√ß√µes FOR rec IN SELECT ... LOOP podem ser otimizadas ‚Äî podemos fazer UPDATE com FROM em vez de loops. Se for seu caso, eu adapto.
Rollback / debug: se algo falhar no trigger, a transa√ß√£o que originou a altera√ß√£o ser√° revertida ‚Äî cuide das mensagens de erro das fun√ß√µes PL/pgSQL.
Testes: execute inser√ß√µes/updates/deletes em ambiente de staging antes de aplicar em produ√ß√£o.